# Product types

Values of product types contain several other values called fields.

``` haskell
data Person = P String String Int
yoda = P "Yoda" "Dagobah" 900
```

Every value of type *Person* is created using the data constructor *P* followed
by three fields: *String*, *String*, *Int*.

## Exercise
 * Define a sum type called *Propulsion* with possible values: *Wind*, *Diesel*.
 * Define a type called *Ship* that has the following properties: *propulsion
   system*, *length in feets*, *passenger capacity*.

# Pattern matching

Pattern matching works on product types just as it works on sum types.

``` haskell
name :: Person -> String
name (P name address age) = name

address :: Person -> String
address (P name address age) = address

age :: Person -> Int
age (P name address age) = age
```

## Exercise
 * Write the extractor functions for your type.

# Record syntax

In the previous examples we saw functions that extract one field of a product
type.  It would be really annoying to define a function for each field in a
large data structure.  Fortunately this can be solved using *Record syntax*
which is just syntactic sugar.

``` haskell
data Person = P { name :: String, address :: String, age :: Int }
```

## Exercise
 * Rewrite your type using record syntax.

