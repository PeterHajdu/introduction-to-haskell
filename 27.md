# Lambda functions

Lambda functions are anonymous functions.  When you need a small function and
you do not want to create a separate declaration, a lambda function might be the
best choice.

Let's have a look at a few examples.
``` haskell
\x -> x + 2
\x y -> x + y
```

The "\" character resembles lambda.  Between lambda and "->" are the function
parameters, after that is the function body.  You can use lambda functions
everywhere where you would use a function.

``` haskell
map (\x -> if even x then "even" else "odd") [1..10]
```

## Exercise

  * Read a line from standard input and write out the length of each word in
    order.  Try to use lambda functions and higher order functions.

``` bash
Please enter a line: this is a line
[4, 2, 1, 4]
```

  * Try to print out the result using *mapM_* or *traverse*.  First have a look
    at their type signature.  If it looks intimidating try to replace type
    constructors with *IO* and *[]*.


# Function composition

Functions in Haskell can be composed just as they can be in math.  If the
function types match you can compose them by simply putting a dot between them.

``` haskell
:t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

The composition operator takes two function parameters and returns the function
that is the composition of its parameters.

## Exercise:

  * What is the type of the following functions and what are they doing?

``` haskell
show . (*2)
length . (++[1..10])
(+2) . (*10)
```

  * Rewrite your code from the lambda function lecture to print out *even* if
    the length of the word is even and *odd* otherwise.  The following function
    might be useful *evenOdd :: Bool -> String*.  Use higher order functions and
    function composition.

  * Create an operator that does the same thing as (.) but with the parameters
    swapped.

``` haskell
(>>>) :: (a -> b) -> (b -> c) -> a -> c
f >>> g = undefined
```
