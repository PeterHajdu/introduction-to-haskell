# Higher order functions

## Fold

Folds are used to process data structures to a single return value.  Some
languages call it *reduce*.

There are many kinds of fold, first we will have a look at *fold right*.

## Foldr

``` haskell
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

The foldable typeclass describes types that can be folded.  List is an instance
of the foldable typeclass.  Replacing *t a* with *[a]* might help in reading the
type signature.

Let's go through the parameters one-by-one:

  * *(a -> b -> b)* : This is a function that accepts a value from the foldable
    and a value that has the same type as the result of the fold.  It combines
    one element of the data structure with the values processed so far.
  * *b* : This is the type that is the result of the fold.  This value is used
    by the combinator function the first time it is called.
  * *t a* : This is the data structure that we are folding.

Let's see a simple example.

``` haskell
f :: Show a => a -> String -> String
f n acc = (show n) ++ acc

foldr f "" [1..5]
```

The combinator function converts the content of the foldable to string and
concatenates it to the already combined value.

``` haskell
(show 1 ++ (show 2 ++ (show 3 ++ (show 4 ++ (show 5 ++ "")))))
```

The second parameter of foldr (the empty String) is combined with the last
item of the foldable.

## Exercise
  * Create a list with type *[Knight]* and using foldr implement the following
    function.

``` haskell
concatColours :: Foldable t => t Knight -> String
```

## Foldl

Let's compare the type of left fold with the type of right fold.

``` haskell
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

The only visible difference is in the type of the combinator function.  The
function's first parameter is the already combined value and the second
parameter is the next value from the foldable.  Now let's see how it works.

Try out the following in ghci.
``` haskell
f :: Show a => a -> String -> String
f n acc = (show n) ++ acc

g :: Show a => String -> a -> String
g acc n = acc ++ (show a)

foldr f "" [1..5]
foldl g "" [1..5]
```

*g* is the same function as *f* with swapped parameters to conform to *foldl*
and accumulator is on the left side of concatenation operator.  To emphasize the
difference between the two folds, let's run the following.

``` haskell
foldr f "!" [1..5]
foldl g "!" [1..5]
```

So foldl would do something like this:

``` haskell
-- foldl
((((("!" ++ show 1) ++ show 2) ++ show 3) ++ show 4) ++ show 5)

--foldr
(show 1 ++ (show 2 ++ (show 3 ++ (show 4 ++ (show 5 ++ "!")))))
```

## Exercise
 * Write the *mysum :: (Num a, Foldable t) => t a -> a* function.

## map or fold?

Fold gives you much more power than map.  With fold in each iteration you get
access to the previous elements of the data structure in the form of the *acc*
parameter.  With map you have access only to one element at a time.
Another benefit is that you can change the data structure.  *map* can change only
the content of the data structure but not the structure itself.

Whenever you need one of these features, use fold otherwise use map.

## Which fold should I use?

It is a hard question, and can not give complete answer to it because we have
not talked about lazy evaluation, which is a key factor.  For now follow these
guidelines:

 * If the foldable is an infinite structure (hint: *repeat 10*) you should use
   *foldr*.
 * If the foldable is finite and it needs to be evaluated always completely,
   than import *Data.List* and use *foldl'* which is identical to foldl.

